
// Fisher-Yates shuffle algorithm https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
function shuffle(array) {
	var m = array.length, t, i;

	// While there remain elements to shuffle…
	while (m) {

		// Pick a remaining element…
		i = Math.floor(Math.random() * m--);

		// And swap it with the current element.
		t = array[m];
		array[m] = array[i];
		array[i] = t;
	}

	return array;
}

// Global for storing experiment sequence that is produced after reading in the experiment sequence
var trialData = " ";

// Takes info from CSV file and obtains experiment sequence that is encoded and returned as a 2D list
function processData(allText) {

	// Regex to split CSV format into 2D matrix 
	var allTextLines = allText.split(/\r\n|\n/);

	// Headers for each column that are stored as the first row in the matrix
	var headers = allTextLines[0].split(',');

	// Removes any blank headers 
	while (headers[headers.length - 1] == "") {
		headers.pop();
	}

	// Stores experiment lines 
	var lines = [];

	// Iterates through rows, each of which stores a list of experiment codes
	for (var i = 1; i < allTextLines.length; i++) {

		// splits comma separated experiment codes for current row
		var data = allTextLines[i].split(',');

		// Removes empty columns
		while (data[data.length - 1] == "") {
			data.pop();
		}

		// Checks to see that removing empty columns did not lead to an uneven row length. If this happens,
		// the CSV file is not properly formatted
		if (data.length == headers.length) {

			// Array storing the specific experiment codes from each string 
			var tarr = [];

			// Iterates through the experiment sequence for the current row
			for (var j = 0; j < data.length; j++) {

				// The experiment codes are stored in the format 'experimentnumberplurality' i.e. 12s means the 12th 
				// monster singular will be the stimulus
				var curr = data[j]

				// Pushes a tuple storing the monster number and plurality by splitting the string 
				tarr.push([curr.substring(0, curr.length - 1), curr.substring(curr.length - 1)]);
			}

			// Pushes to matrix
			lines.push(tarr);
		}
	}

	// Sets trialData global to the matrix generated by the method
	trialData = lines;
}

// Given an image number, outputs a string with the file name for that image
function imageFileName(imageNumber) {

	// Small images
	if (imageNumber < 12) {
		return "l" + imageNumber + 1 + ".png";
	}

	// Large images
	else {
		return "h" + imageNumber - 18 + 1 + ".png";
	}
}

// Given the determiner number, a boolean with true-> small, false-> big, a monster number and a boolean 
// with true->singular false->plural, outputs the file name for the associated sound file
function soundFileName(determiner, isSmall, monsterNumber, isSingular) {

	// Encodes determiner number
	var det = "det" + determiner + "_";
	var size;

	// Encodes size based on boolean value
	if (isSmall) {
		size = "small";
	}
	else {
		size = "big";
	}
	var plurality;

	// Encodes plurality based on boolean value
	if (isSingular) {
		plurality = "s";
	}
	else {
		plurality = "p";
	}

	// Concatenates all encodings as they appear in the file name
	return det + size + monsterNumber + plurality + ".wav";
}

function constructValues() {

	// Shuffles between the 4 determiners and randomly assigns them to the small and big plural and singular forms
	var dets = [1, 2, 3, 4]
	shuffle(dets)
	detSmallSing = dets[0]
	detSmallPlur = dets[1]
	detLargeSing = dets[2]
	detLargePlur = dets[3]

	// Constructs file dictionary for small monsters
	for (var i = 0; i < 17; i++) {
		// Retrieves image file
		var img = imageFileName(i)
		// Retrieves sounds for plural and singular with selected determiner
		var singSound = soundFileName(detSmallSing, true, i, true)
		var plurSound = soundFileName(detSmallPlur, true, i, false)
		// Adds current monster to dictionary in the structure 
		// [image file name, sub-dictionary storing plural sound file with key p and singular sound file with key s, sub-dictionary storing plural prompt string with key p and singular prompt string with key s]
		small[i] = [img, { "p": plurSound, "s": singSound }]
	}
	// Constructs file dictionary for large monsters
	for (var i = 18; i < 30; i++) {
		// Retrieves image file
		img = imageFileName(i)
		// Retrieves sounds for plural and singular with selected determiner
		singSound = soundFileName(detLargeSing, true, i, true)
		plurSound = soundFileName(detLargePlur, true, i, false)
		// Adds current monster to dictionary in the structure 
		// [image file name, sub-dictionary storing plural sound file with key p and singular sound file with key s, sub-dictionary storing plural prompt string with key p and singular prompt string with key s]
		big[i - 18] = [img, { "p": plurSound, "s": singSound }, { "p": soundToPrompt[plurSound], "s": soundToPrompt[singSound] }]
	}
}
// Lists of instructions for comprehension and production trials
// TODO: These are not currently the right file names for the sequences
prodMessageSequence = ["openingmessagep", "Overviewmessage", "Audiocheckmessage1", "Audiocheckmessage2", "Audiocheckmessage3", "Passivemessage1", "Passivemessage", "Passivemessage2"
	, "activeprodmessage1", "activeprodmessage", "activeprodmessage2", "Passivemessage", "activeprodmessage", "Audiocheckmessage", "Breakmessage", "forcedchoicemessage2pic",
	"audiocheckmessage", "breakmessage", "forcedchoicemessage4pic", "audiocheckmessage", "breakmessage", "grammaticalityjudgment",
	"audiocheckmessage", "breakmessage", "prodtest1", "prodtest2", "audiocheckmessage", "breakmessage", "prodtestmessage"]
compMessageSequence = ["openingmessagep", "Overviewmessage", "Audiocheckmessage1", "Audiocheckmessage2", "Audiocheckmessage3", "Passivemessage1", "Passivemessage", "Passivemessage2"
	, "activeprodmessage1", "activeprodmessage", "activeprodmessage2", "Passivemessage", "activeprodmessage", "Audiocheckmessage", "Breakmessage", "forcedchoicemessage2pic",
	"audiocheckmessage", "breakmessage", "forcedchoicemessage4pic", "audiocheckmessage", "breakmessage", "grammaticalityjudgment",
	"audiocheckmessage", "breakmessage", "prodtest1", "prodtest2", "audiocheckmessage", "breakmessage", "prodtestmessage"]

// Global storing the current instruction within the trial
var currentInstructionCounter = 0

// Plays the next instruction in the sequence for the trial
function playNextInstruction() {

	// Stores timeline object for the instruction 
	var instruction;

	// Checks for comp or prod trial, generates the instruction message timeline object for the appropriate trial
	if (comp) {
		instruction = {
			// Displays message with no user response
			type: 'image-keyboard-response',
			stimulus: compMessageSequence[currentInstructionCounter],
			choices: jsPsych.NO_KEYS,
			trial_duration: 2500
		}
	}
	else {
		instruction = {
			// Displays message with no user response
			type: 'image-keyboard-response',
			stimulus: prodMessageSequence[currentInstructionCounter],
			choices: jsPsych.NO_KEYS,
			trial_duration: 2500
		}
	}
	// Increments counter so next instruction is selected on the next call
	currentInstructionCounter++;
	return instruction;
}

// Generates an experiment timeline 
function makeExp() {

	// Obtains boolean value 'comp' from URL which encodes whether the experiement will be production or comprehension
	const queryString = window.location.search;
	const urlParams = new URLSearchParams(queryString);
	const comp = urlParams.get('comp') == 'true';

	// Constructs dictionary of appropriate sound and image files
	constructValues()

	// Obtains big and small values from the dictionary storing their data
	var bigValues = Object.values(big);
	var smallValues = Object.values(small);

	// Obtains the specific image and sound files for each of the big and small data files
	var bigImages = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigImages.push(bigValues[i][0]);
	}
	var smallImages = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallImages.push(smallValues[i][0]);
	}
	var bigSounds = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigSounds.push(bigValues[i][1]);
	}
	var smallSounds = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallSounds.push(smallValues[i][1]);
	}
	var bigPrompts = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigSounds.push(bigValues[i][1]);
	}
	var smallPrompts = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallSounds.push(smallValues[i][1]);
	}

	// Shuffles the big and small images, sounds and prompts
	shuffle(bigImages);
	shuffle(smallImages);
	shuffle(bigSounds);
	shuffle(smallSounds);
	shuffle(bigPrompts);
	shuffle(smallPrompts);

	// Concatenates images such that 0-17 are big, 18-29 small
	var allImages = bigImages.concat(smallImages);
	var allSounds = bigSounds.concat(smallSounds);
	var allPrompts = bigPrompts.concat(smallPrompts);

	// Shuffles the row sequences in trial data 
	shuffle(trialData);

	// Stores experiment timeline object
	experiments = []

	// Iterates through the rows in the trial data matrix
	for (var i = 0; i < trialData.length; i++) {

		// Current row
		curr = trialData[i];

		// Stores experiment block for this row
		block = [];

		// Shuffles the row itself
		shuffle(curr);

		// Iterates through the row, obtaining trial objects
		for (var j = 0; j < curr.length; j++) {

			// Obtains monster number and plurality from the parsed data
			var monsterIndex = parseInt(curr[j][0]);
			var singOrPlural = curr[j][1];

			// Calls functions to obtain trial objects and pushes them to the timeline
			// this part of the experiment contains passive comprehension trials
			block.push(passive_comprehension_trial(allImages[monsterIndex],
				allSounds[monsterIndex][singOrPlural], allPrompts[monsterIndex][singOrPlural]));
		}

		// Shuffles the row sequence once again
		shuffle(curr);

		// Comprehension trial
		if (comp) {

			// Same process as passive trial but generates active comprehension trial 
			for (var j = 0; j < curr.length; j++) {
				var monsterIndex = parseInt(curr[j][0]);
				var singOrPlural = curr[j][1];
				block.push(active_comprehension_trial(
					allImages[monsterIndex],
					allSounds[monsterIndex][singOrPlural], allPrompts[monsterIndex][singOrPlural]));
			}
		}
		// Production trial 
		else {
			for (var j = 0; j < curr.length; j++) {
				var monsterIndex = parseInt(curr[j][0]);
				var singOrPlural = curr[j][1];
				// What should the prompt be?
				block.push(active_production_trial(allImages[monsterIndex],
					allSounds[monsterIndex][singOrPlural], allPrompts[monsterIndex][singOrPlural]));
			}
		}
		// Pushes block of experiments to matrix
		experiments.push(block);
	}

	// Returns matrix of experiment timelines
	return experiments;
}
